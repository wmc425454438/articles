# 字符串扩展

## 1.字符的Unidcode表示方法

JavaScript 允许采用`\uxxxx`形式表示一个字符，其中`xxxx`表示字符的 Unicode 码点。

但是，这种表示法只限于码点在`\u0000~\uFFFF`之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。

如果直接在`\u`后面跟上超过`0xFFFF`的数值（比如`\u20BB7`），JavaScript 会理解成`\u20BB+7`。由于`\u20BB`是一个不可打印字符，所以只会显示一个空格，后面跟着一个`7`。

ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。

``` js
"\u0061"
// "a"

"\uD842\uDFB7"
// "𠮷"

"\u20BB7"
// " 7"

"\u{20BB7}"
// "𠮷"

"\u{41}\u{42}\u{43}"
// "ABC"

let hello = 123;
'hell\u{6F}' // 123

'\u{1F680}' === '\uD83D\uDE80'
// true
```

有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。

``` js
'\z' === 'z'  // true  转义字符
'\172' === 'z' // true  8进制
'\x7A' === 'z' // true   16进制
'\u007A' === 'z' // true  Unicode
'\u{7A}' === 'z' // true   ES6大括号
```

## 2.codePointAt()

ES6 提供了`codePointAt`方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。

使用for...of循环，它会正确识别 32 位的 UTF-16 字符。
``` js
let s = '𠮷a';
for (let ch of s) {
  console.log(ch.codePointAt(0).toString(16));
}
// 20bb7
// 61
```

`codePointAt`方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。

``` js
function is32Bit(c) {
  return c.codePointAt(0) > 0xFFFF;
}

is32Bit("𠮷") // true
is32Bit("a") // false
```

