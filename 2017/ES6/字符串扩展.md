# 字符串扩展

## 1.字符的Unidcode表示方法

JavaScript 允许采用`\uxxxx`形式表示一个字符，其中`xxxx`表示字符的 Unicode 码点。

但是，这种表示法只限于码点在`\u0000~\uFFFF`之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。

如果直接在`\u`后面跟上超过`0xFFFF`的数值（比如`\u20BB7`），JavaScript 会理解成`\u20BB+7`。由于`\u20BB`是一个不可打印字符，所以只会显示一个空格，后面跟着一个`7`。

ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。

``` js
"\u0061"
// "a"

"\uD842\uDFB7"
// "𠮷"

"\u20BB7"
// " 7"

"\u{20BB7}"
// "𠮷"

"\u{41}\u{42}\u{43}"
// "ABC"

let hello = 123;
'hell\u{6F}' // 123

'\u{1F680}' === '\uD83D\uDE80'
// true
```

有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。

``` js
'\z' === 'z'  // true  转义字符
'\172' === 'z' // true  8进制
'\x7A' === 'z' // true   16进制
'\u007A' === 'z' // true  Unicode
'\u{7A}' === 'z' // true   ES6大括号
```

## 2.codePointAt()

ES6 提供了`codePointAt`方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。

使用for...of循环，它会正确识别 32 位的 UTF-16 字符。
``` js
let s = '𠮷a';
for (let ch of s) {
  console.log(ch.codePointAt(0).toString(16));
}
// 20bb7
// 61
```

`codePointAt`方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。

``` js
function is32Bit(c) {
  return c.codePointAt(0) > 0xFFFF;
}

is32Bit("𠮷") // true
is32Bit("a") // false
```
## 3. String.fromCodePoint()

是`codePointAt`的反操作 
``` js
String.fromCodePoint(0x20BB7)
// "𠮷"
String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\uD83D\uDE80y'
// true
```

## 4. 字符串的遍历器接口

ES6 为字符串添加了遍历器接口，使得字符串可以被for...of循环遍历。这个的最大好处可以识别大于`0xFFFF`的码点。
``` js
for (let codePoint of 'foo') {
  console.log(codePoint)
}
// "f"
// "o"
// "o"

let text = String.fromCodePoint(0x20BB7);

//传统for循环无法识别
for (let i = 0; i < text.length; i++) {
  console.log(text[i]);
}
// " "
// " "

for (let i of text) {
  console.log(i);
}
// "𠮷"
```


## 5. at()
``` js
'abc'.charAt(0) // "a"
'𠮷'.charAt(0) // "\uD842"

'abc'.at(0) // "a"
'𠮷'.at(0) // "𠮷"
```
这个方法可以通过[垫片库](https://github.com/es-shims/String.prototype.at)实现。






















